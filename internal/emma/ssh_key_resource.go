package emma

import (
	"context"
	"fmt"
	emmaSdk "github.com/emma-community/emma-go-sdk"
	emma "github.com/emma-community/terraform-provider-emma/internal/emma/validation"
	"github.com/emma-community/terraform-provider-emma/tools"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"strconv"
)

var _ resource.Resource = &sshKeyResource{}

func NewSshKeyResource() resource.Resource {
	return &sshKeyResource{}
}

// sshKeyResource defines the resource implementation.
type sshKeyResource struct {
	apiClient *emmaSdk.APIClient
	token     *emmaSdk.Token
}

// sshKeyResourceModel describes the resource data model.
type sshKeyResourceModel struct {
	Id          types.String `tfsdk:"id"`
	Name        types.String `tfsdk:"name"`
	Key         types.String `tfsdk:"key"`
	Fingerprint types.String `tfsdk:"fingerprint"`
	KeyType     types.String `tfsdk:"key_type"`
	PrivateKey  types.String `tfsdk:"private_key"`
}

func (r *sshKeyResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_ssh_key"
}

func (r *sshKeyResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		// This description is used by the documentation generator and the language server.
		Description: "This method creates an SSH key that can be used for Linux compute instance creation. " +
			"An SSH key can be created in two ways: generated by emma or imported by the user.\n\n" +
			"If you want to **generate** a key, specify two fields: name and key_type (RSA or ED25519). " +
			"The key will be generated, and you will receive a private key in the response. The private key will be " +
			"shown only once, so copy and save it to connect to the Linux compute instances.\n\n" +
			"If you want to **import** an existing SSH key, specify two fields: name and key. In the key field, insert " +
			"your public SSH key as a string. It will be imported.",

		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Description: "ID of the SSH key",
				Computed:    true,
			},
			"name": schema.StringAttribute{
				Description: "SSH key name",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Validators:  []validator.String{emma.NotBlankString{}, emma.SshKeyName{}},
			},
			"key": schema.StringAttribute{
				Description:   "SSH public key, ssh key will be recreated after changing this value",
				Computed:      false,
				Required:      false,
				Optional:      true,
				PlanModifiers: []planmodifier.String{stringplanmodifier.RequiresReplace()},
				Validators:    []validator.String{emma.NotEmptyString{}},
			},
			"fingerprint": schema.StringAttribute{
				Description: "SSH key fingerprint",
				Computed:    true,
			},
			"key_type": schema.StringAttribute{
				Description:   "SSH key type, available values: RSA or ED25519, ssh key will be recreated after changing this value",
				Computed:      false,
				Required:      false,
				Optional:      true,
				PlanModifiers: []planmodifier.String{stringplanmodifier.RequiresReplace()},
				Validators:    []validator.String{emma.KeyType{}},
			},
			"private_key": schema.StringAttribute{
				Description: "SSH private key",
				Computed:    true,
			},
		},
	}
}

func (r *sshKeyResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*Client)
	if !ok {
		resp.Diagnostics.AddError("Unexpected Data Source Configure Type",
			fmt.Sprintf("Expected *Client, got: %T. Please report this issue to the provider developers.",
				req.ProviderData))
		return
	}
	r.apiClient = client.apiClient
	r.token = client.token
}

func (r *sshKeyResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data sshKeyResourceModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)

	if (!data.Key.IsUnknown() && !data.Key.IsNull()) && (!data.KeyType.IsUnknown() && !data.KeyType.IsNull()) {
		resp.Diagnostics.AddError("Validation Error",
			fmt.Sprintf("Unable to create ssh key: contradicting fields: key_type, key"))
	} else if (data.Key.IsUnknown() || data.Key.IsNull()) && (data.KeyType.IsUnknown() || data.KeyType.IsNull()) {
		resp.Diagnostics.AddError("Validation Error",
			fmt.Sprintf("Unable to create ssh key: key or key_type is required"))
	}

	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Info(ctx, "Create ssh key")

	// If applicable, this is a great opportunity to initialize any necessary
	// provider client data and make a call using it.
	var sshKeyCreateImportRequest emmaSdk.SshKeysCreateImportRequest
	ConvertToSshKeyCreateImportRequest(data, &sshKeyCreateImportRequest)
	auth := context.WithValue(ctx, emmaSdk.ContextAccessToken, *r.token.AccessToken)

	sshKey, response, err := r.apiClient.SSHKeysAPI.SshKeysCreateImport(auth).SshKeysCreateImportRequest(sshKeyCreateImportRequest).Execute()

	if err != nil {
		resp.Diagnostics.AddError("Client Error",
			fmt.Sprintf("Unable to create ssh key, got error: %s",
				tools.ExtractErrorMessage(response)))
		return
	}

	ConvertSshKey201ResponseToResource(&data, sshKey)

	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *sshKeyResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data sshKeyResourceModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Info(ctx, "Read ssh key")

	// If applicable, this is a great opportunity to initialize any necessary
	// provider client data and make a call using it.
	auth := context.WithValue(ctx, emmaSdk.ContextAccessToken, *r.token.AccessToken)
	sshKey, response, err := r.apiClient.SSHKeysAPI.GetSshKey(auth, tools.StringToInt32(data.Id.ValueString())).Execute()

	if err != nil {
		resp.Diagnostics.AddError("Client Error",
			fmt.Sprintf("Unable to read ssh key, got error: %s",
				tools.ExtractErrorMessage(response)))
		return
	}

	ConvertSshKeyResponseToResource(&data, nil, sshKey)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *sshKeyResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var planData sshKeyResourceModel
	var stateData sshKeyResourceModel

	// Read Terraform plan planData into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &planData)...)
	resp.Diagnostics.Append(req.State.Get(ctx, &stateData)...)

	if (!planData.Key.IsUnknown() && !planData.Key.IsNull()) && (!planData.KeyType.IsUnknown() && !planData.KeyType.IsNull()) {
		resp.Diagnostics.AddError("Validation Error",
			fmt.Sprintf("Unable to update ssh key: contradicting fields: key_type, key"))
	} else if (planData.Key.IsUnknown() || planData.Key.IsNull()) && (planData.KeyType.IsUnknown() || planData.KeyType.IsNull()) {
		resp.Diagnostics.AddError("Validation Error",
			fmt.Sprintf("Unable to update ssh key: key or key_type is required"))
	}

	tflog.Info(ctx, "Update ssh key")

	if resp.Diagnostics.HasError() {
		return
	}

	// auth context for all api calls
	auth := context.WithValue(ctx, emmaSdk.ContextAccessToken, *r.token.AccessToken)

	var sshKeyUpdateRequest emmaSdk.SshKeyUpdate
	ConvertToSshKeyUpdateRequest(planData, &sshKeyUpdateRequest)
	sshKey, response, err := r.apiClient.SSHKeysAPI.SshKeyUpdate(auth, tools.StringToInt32(stateData.Id.ValueString())).SshKeyUpdate(sshKeyUpdateRequest).Execute()

	if err != nil {
		resp.Diagnostics.AddError("Client Error",
			fmt.Sprintf("Unable to update ssh key, got error: %s",
				tools.ExtractErrorMessage(response)))
		return
	}

	ConvertSshKeyResponseToResource(&stateData, &planData, sshKey)

	// Save planData into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &stateData)...)
}

func (r *sshKeyResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data sshKeyResourceModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Info(ctx, "Delete ssh key")

	auth := context.WithValue(ctx, emmaSdk.ContextAccessToken, *r.token.AccessToken)
	Delete(auth, r, data, resp.Diagnostics)
}

func Delete(ctx context.Context, r *sshKeyResource, stateData sshKeyResourceModel, diag diag.Diagnostics) {
	response, err := r.apiClient.SSHKeysAPI.SshKeyDelete(ctx, tools.StringToInt32(stateData.Id.ValueString())).Execute()

	// If applicable, this is a great opportunity to initialize any necessary
	// provider client data and make a call using it.
	if err != nil {
		diag.AddError("Client Error",
			fmt.Sprintf("Unable to delete ssh key, got error: %s",
				tools.ExtractErrorMessage(response)))
		return
	}
}

func (r *sshKeyResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	tflog.Info(ctx, "Import ssh key")

	// Retrieve import ID and save to id attribute
	resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)

	r.Read(ctx, resource.ReadRequest{State: resp.State, Private: resp.Private},
		&resource.ReadResponse{State: resp.State, Private: resp.Private, Diagnostics: resp.Diagnostics})
}

func ConvertToSshKeyCreateImportRequest(data sshKeyResourceModel, sshKeyCreate *emmaSdk.SshKeysCreateImportRequest) {
	if !data.KeyType.IsNull() {
		sshKeyCreateRequest := emmaSdk.SshKeyCreate{}
		sshKeyCreateRequest.Name = data.Name.ValueString()
		sshKeyCreateRequest.KeyType = data.KeyType.ValueString()
		sshKeyCreate.SshKeyCreate = &sshKeyCreateRequest
	} else if !data.Key.IsNull() {
		sshKeyImportRequest := emmaSdk.SshKeyImport{}
		sshKeyImportRequest.Name = data.Name.ValueString()
		sshKeyImportRequest.Key = data.Key.ValueString()
		sshKeyCreate.SshKeyImport = &sshKeyImportRequest
	}
}

func ConvertToSshKeyUpdateRequest(data sshKeyResourceModel, sshKeyUpdate *emmaSdk.SshKeyUpdate) {
	sshKeyUpdate.Name = data.Name.ValueString()
}

func ConvertSshKey201ResponseToResource(data *sshKeyResourceModel, sshKeyResponse *emmaSdk.SshKeysCreateImport201Response) {
	if sshKeyResponse.SshKey != nil {
		ConvertSshKeyResponseToResource(data, nil, sshKeyResponse.SshKey)
	} else if sshKeyResponse.SshKeyGenerated != nil {
		data.Id = types.StringValue(strconv.Itoa(int(*sshKeyResponse.SshKeyGenerated.Id)))
		data.Name = types.StringValue(*sshKeyResponse.SshKeyGenerated.Name)
		if !data.Key.IsUnknown() && !data.Key.IsNull() {
			data.Key = types.StringValue(*sshKeyResponse.SshKeyGenerated.Key)
		} else {
			data.Key = types.StringNull()
		}
		if !data.KeyType.IsUnknown() && !data.KeyType.IsNull() {
			data.KeyType = types.StringValue(*sshKeyResponse.SshKeyGenerated.KeyType)
		} else {
			data.KeyType = types.StringNull()
		}
		data.Fingerprint = types.StringValue(*sshKeyResponse.SshKeyGenerated.Fingerprint)
		if sshKeyResponse.SshKeyGenerated.PrivateKey != nil {
			data.PrivateKey = types.StringValue(*sshKeyResponse.SshKeyGenerated.PrivateKey)
		} else if !data.PrivateKey.IsUnknown() && !data.PrivateKey.IsNull() {
			//ignore
		} else {
			data.PrivateKey = types.StringValue("")
		}
	}
}

func ConvertSshKeyResponseToResource(stateData *sshKeyResourceModel, planData *sshKeyResourceModel, sshKeyResponse *emmaSdk.SshKey) {
	stateData.Id = types.StringValue(strconv.Itoa(int(*sshKeyResponse.Id)))
	stateData.Name = types.StringValue(*sshKeyResponse.Name)
	if (planData != nil && !planData.Key.IsUnknown() && !planData.Key.IsNull()) ||
		(!stateData.Key.IsUnknown() && !stateData.Key.IsNull()) {
		stateData.Key = types.StringValue(*sshKeyResponse.Key)
	} else {
		stateData.Key = types.StringNull()
	}
	if (planData != nil && !planData.KeyType.IsUnknown() && !planData.KeyType.IsNull()) ||
		(!stateData.KeyType.IsUnknown() && !stateData.KeyType.IsNull()) {
		stateData.KeyType = types.StringValue(*sshKeyResponse.KeyType)
	} else {
		stateData.KeyType = types.StringNull()
	}
	stateData.Fingerprint = types.StringValue(*sshKeyResponse.Fingerprint)
	if stateData.PrivateKey.IsNull() || stateData.PrivateKey.IsUnknown() {
		stateData.PrivateKey = types.StringValue("")
	}
}
